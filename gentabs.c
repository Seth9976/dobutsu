/* program to make various tables for poscode.c */

/*
 * See the comments for what tables are created.
 *
 * In the encoding tables, entries that do not have an encoding are
 * marked by being set to -1.
 */

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "dobutsu.h"

extern int main()
{
	int i, L, l;
	unsigned char lion_decoding[24], pos2_decoding[56];
	char lion_encoding[56], pos2_encoding[121];

	printf("#include \"dobutsu.h\"\n\n"
	    "/*\n * Tables for poscode.c generated by gentabs.\n"
	    " * This is a generated file, do not edit.\n"
	    " * See gentabs.c for documentation.\n"
	    " */\n\n");

	/* generate lion_decoding */
	i = 0;
	for (L = 0; L <= 6; L++) {
		/* fields the sente Lion cannot be on */
		if (!(00133 & 1 << L))
			continue;

		for (l = 5; l <= 11; l++) {
			/* if gote lion is in check, the position is invalid */
			if (L == l || Llmoves[L] & 1 << l)
				continue;

			lion_decoding[i++] = L << 4 | l;
		}
	}

	assert(i == 24); /* make sure I got the count right */

	/*
	 * decoding table for the lion's positions. First nibble is the
	 * sente lion's field number, gote is the gote lion's field.
	 */
	printf("const unsigned char lion_decoding[24] = {");
	for (i = 0; i < 24; i++)
		printf("%s%#04x,", i % 8 == 0 ? "\n\t" : " ", lion_decoding[i]);
	printf("\n};\n\n");

	/* generate lion_encoding */
	memset(lion_encoding, -1, sizeof lion_encoding);
	for (i = 0; i < 24; i++) {
		L = lion_decoding[i] >> 4;
		l = lion_decoding[i] & 0xf;

		lion_encoding[8 * L + l - 5] = i;
	}

	/*
	 * encoding table for the lion's positions. The index has the
	 * form 8 * L + (l - 5) where 0 <= L <= 7 and 5 <= l <= 11. A
	 * factor of 7 would have been sufficient, but 8 is faster to
	 * compute and only wastes seven bytes of RAM.
	 */
	printf("const signed char lion_encoding[7 * 8] = {");
	for (i = 0; i < 7 * 8; i++)
		printf("%s%2d,", i % 8 == 0 ? "\n\t" : " ", lion_encoding[i]);
	printf("\n};\n\n");

	/*
	 * The first step in encoding the positions of the non-lion
	 * pieces is to remove the two fields occupied by the lions from
	 * the number of legal places, reducing the encoding from the
	 * range 0--12 to 0--10.  The index into this table has the form
	 * Ll * 11 + pos where Ll are the encoded lion positions and pos
	 * is the reduced. position of the piece.
	 */
	printf("const unsigned char pos1_decoding[24 * 11] = {");
	for (i = 0; i < 24 * 11; i++) {
		unsigned Ll = lion_decoding[i / 11], pos = i % 11;

		/*
		 * make sure our expression below works for 0x65,
		 * the only case where L < l
		 */
		if (Ll == 0x65)
			Ll = 0x56;
		L = Ll >> 4;
		l = Ll & 0xf;

		printf("%s%2u,", i % 11 == 0 ? "\n\t" : " ", pos + (pos >= L) + (pos >= l - 1));
	}

	printf("\n};\n\n");

	/*
	 * This table encodes what is decoded by the previous table.
	 * The index has the form Ll * 13 + pos, similar to the previous
	 * one.
	 */
	printf("const signed char pos1_encoding[24 * 13] = {");
	for (i = 0; i < 24 * 13; i++) {
		unsigned Ll = i / 13, pos = i % 13, L, l;
		int encode;

		L = lion_decoding[Ll] >> 4;
		l = lion_decoding[Ll] & 0xf;

		if (pos == L || pos == l)
			encode = -1;
		else
			encode = pos - (pos > L) - (pos > l);

		printf("%s%2d,", i % 13 == 0 ? "\n\t" : " ", encode);
	}

	printf("\n};\n\n");

	/*
	 * After reducing the field number, we encode each pair of
	 * pieces of the same type together by observing that we can
	 * always make one piece have a lower field number than the
	 * other.  This saves one bit per piece.  There are 56 possible
	 * encodings: 55 coming from 10 + 9 + ... + 1 for the each way
	 * we can place the higher valued piece and one for the special
	 * case of both pieces being in hand.  The value in the table
	 * has the same form as for the lions: High nibble is for the
	 * first piece, low nibble for the second.
	 */
	i = 0;
	pos2_decoding[i++] = 0xaa;
	for (L = 10; L > 0; L--)
		for (l = L - 1; l >= 0; l--)
			pos2_decoding[i++] = L << 4 | l << 0;

	assert(i == 56);

	/* print out the pos2_decoding table */
	printf("const unsigned char pos2_decoding[11 * 10 / 2 + 1] = {");
	for (i = 0; i < 56; i++)
		printf("%s%#4x,", i % 8 == 0 ? "\n\t" : " ", pos2_decoding[i]);
	printf("\n};\n\n");

	/*
	 * This table encodes a pair of pieces as described above.  The
	 * index has the form p * 11 + P where P is the piece on the
	 * higher field and p is the piece on the lower field.  We don't
	 * care about parity here, pieces with wrong parity are silently
	 * flipped.  Invalid entries (main diagonal) are marked -1.
	 */
	memset(pos2_encoding, -1, sizeof pos2_encoding);
	for (i = 0; i < 56; i++) {
		pos2_encoding[(pos2_decoding[i] & 15) * 11 + (pos2_decoding[i] >> 4)] = i;
		pos2_encoding[(pos2_decoding[i] >> 4) * 11 + (pos2_decoding[i] & 15)] = i;
	}

	/* print out the pos2_encoding table */
	printf("const signed char pos2_encoding[11 * 11] = {");
	for (i = 0; i < 121; i++)
		printf("%s%2d,", i % 11 == 0 ? "\n\t" : " ", pos2_encoding[i]);
	printf("\n};\n\n");


	/*
	 * the flip_op table contains at each index the index xored
	 * with the op byte represented by the index but with the upper
	 * case and lower case pieces flipped.  This is used to speed up
	 * flipping the pieces when establishing parity for encoding.
	 */
	printf("const unsigned char flip_op[256] = {");
	for (i = 0; i < 256; i++)
		printf("%s%#4x,", i % 16 == 0 ? "\n\t" : " ", i ^ ((i & 0x55) << 1 | (i & 0xaa) >> 1));
	printf("\n};\n");

	return (0);
}
