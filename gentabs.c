/* program to make various tables for poscode.c */

/*
 * The following tables are generated:
 *
 * - op_decoding and op_encoding for conversion between the op byte
 *   and the 90 possible op codes
 * - lion_decoding and lion_encoding to encode the possible lion
 *   positions.
 * - pos_decoding and pos_encoding to convert piece positions between
 *   coordinates and lion-excluding coordinates
 *
 * In the encoding tables, entries that do not have an encoding are
 * marked by being set to -1.
 */

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "dobutsu.h"

extern int main()
{
	int i, L, l;
	unsigned char lion_decoding[24], op_decoding[90], pos2_decoding[56];
	char lion_encoding[56], pos2_encoding[110];

	printf("/*\n * Tables for poscode.c generated by gentabs.\n");
	printf(" * This is a generated file, do not edit.\n");
	printf(" * See gentabs.c for documentation.\n */\n\n");

	/* generate lion_decoding */
	i = 0;
	for (L = 0; L <= 6; L++) {
		/* fields the sente Lion cannot be on */
		if (!(00133 & 1 << L))
			continue;

		for (l = 5; l <= 11; l++) {
			/* if gote lion is in check, the position is invalid */
			if (L == l || Llmoves[L] & 1 << l)
				continue;

			lion_decoding[i++] = L << 4 | l;
		}
	}

	assert(i == 24); /* make sure I got the count right */

	/*
	 * decoding table for the lion's positions. First nibble is the
	 * sente lion's field number, gote is the gote lion's field.
	 */
	printf("static const unsigned char lion_decoding[24] = {\n");
	for (i = 0; i < 24; i++)
		printf("%s%#04x,%s", i % 8 == 0 ? "\t" : " ", lion_decoding[i], i % 8 == 7 ? "\n" : "");
	printf("};\n\n");

	/* generate lion_encoding */
	memset(lion_encoding, -1, sizeof lion_encoding);
	for (i = 0; i < 24; i++) {
		L = lion_decoding[i] >> 4;
		l = lion_decoding[i] & 0xf;

		lion_encoding[8 * L + l - 5] = i;
	}

	/*
	 * encoding table for the lion's positions. The index has the
	 * form 8 * L + (l - 5) where 0 <= L <= 7 and 5 <= l <= 11. A
	 * factor of 7 would have been sufficient, but 8 is faster to
	 * compute and only wastes seven bytes of RAM.
	 */
	printf("static const unsigned char lion_encoding[7 * 8] = {\n");
	for (i = 0; i < 7 * 8; i++)
		printf("%s%2d,%s", i % 8 == 0 ? "\t" : " ", lion_encoding[i], i % 8== 7 ? "\n" : "");

	printf("};\n\n");

	/*
	 * The first step in encoding the positions of the non-lion
	 * pieces is to remove the two fields occupied by the lions from
	 * the number of legal places, reducing the encoding from the
	 * range 0--12 to 0--10.  The index into this table has the form
	 * Ll * 11 + pos where Ll are the encoded lion positions and pos
	 * is the reduced. position of the piece.
	 */
	printf("static const unsigned char pos1_decoding[24 * 11] = {\n");
	for (i = 0; i < 24 * 11; i++) {
		unsigned Ll = i / 11, pos = i % 11, L, l;

		L = lion_decoding[Ll] >> 4;
		l = lion_decoding[Ll] & 0xf;

		printf("%s%2u,%s", i % 11 == 0 ? "\t" : " ", pos + (pos >= L) + (pos >= l - 1), i % 11 == 10 ? "\n" : "");
	}

	printf("};\n\n");

	/*
	 * This table encodes what is decoded by the previous table.
	 * The index has the form Ll * 13 + pos, similar to the previous
	 * one.
	 */
	printf("static const signed char pos1_encoding[24 * 13] = {\n");
	for (i = 0; i < 24 * 13; i++) {
		unsigned Ll = i / 13, pos = i % 13, L, l;
		int encode;

		L = lion_decoding[Ll] >> 4;
		l = lion_decoding[Ll] & 0xf;

		if (pos == L || pos == l)
			encode = -1;
		else
			encode = pos - (pos > L) - (pos > l);

		printf("%s%2d,%s", i % 13 == 0 ? "\t" : " ", encode, i % 13 == 12 ? "\n" : "");
	}

	printf("};\n\n");

	/*
	 * After reducing the field number, we encode each pair of
	 * pieces of the same type together by observing that we can
	 * always make one piece have a lower field number than the
	 * other.  This saves one bit per piece.  There are 56 possible
	 * encodings: 55 coming from 10 + 9 + ... + 1 for the each way
	 * we can place the higher valued piece and one for the special
	 * case of both pieces being in hand.  The value in the table
	 * has the same form as for the lions: High nibble is for the
	 * first piece, low nibble for the second.
	 */
	i = 0;
	pos2_decoding[i++] = 0xaa;
	for (L = 10; L > 0; L--)
		for (l = L - 1; l >= 0; l--)
			pos2_decoding[i++] = L << 4 | l << 0;

	assert(i == 56);

	/* print out the pos2_decoding table */
	printf("static const unsigned char pos2_decoding[11 * 10 / 2 + 1] = {\n");
	for (i = 0; i < 56; i++)
		printf("%s%##4x,%s", i % 8 == 0 ? "\t" : " ", pos2_decoding[i], i % 8 == 7 ? "\n" : "");
	printf("};\n\n");

	/*
	 * This table encodes a pair of pieces as described above.  The
	 * index has the form p * 10 + P - 1 where P is the piece on the
	 * higher field and p is the piece on the lower field.  Invalid
	 * entries are marked -1.
	 */
	memset(pos2_encoding, -1, sizeof pos2_encoding);
	for (i = 0; i < 56; i++)
		pos2_encoding[(pos2_decoding[i] & 0xf) * 10 + (pos2_decoding[i] >> 4) - 1] = i;

	/* print out the pos2_encoding table */
	printf("static const signed char pos2_encoding[11 * 10] = {\n");
	for (i = 0; i < 110; i++)
		printf("%s%2d,%s", i % 10 == 0 ? "\t" : " ", pos2_encoding[i], i % 10 == 9 ? "\n" : "");
	printf("};\n");

	return (0);
}
